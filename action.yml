name: 'CRONOS Code Guard'
description: 'Static analysis for Python code changes with risk assessment'
author: 'cythonvijay'
branding:
  icon: 'shield'
  color: 'blue'

inputs:
  api_url:
    description: 'CRONOS API endpoint URL'
    required: true
  mode:
    description: 'Analysis mode: STRICT, BOUNDARY, or CONTRACT'
    required: false
    default: 'STRICT'

runs:
  using: 'composite'
  steps:
    - name: Install dependencies
      shell: bash
      run: |
        if ! command -v jq &> /dev/null; then
          sudo apt-get update -qq
          sudo apt-get install -y jq curl
        fi

    - name: Run CRONOS Analysis
      shell: bash
      env:
        API_URL: ${{ inputs.api_url }}
        MODE: ${{ inputs.mode }}
      run: |
        set -euo pipefail
        API_URL="${API_URL%/}"
        REPORT_DIR="cronos-reports"
        mkdir -p "$REPORT_DIR"
        echo "CRONOS Analysis - Mode=$MODE API=$API_URL"

        if ! curl -sf --max-time 10 "$API_URL/" > /dev/null 2>&1; then
          echo "ERROR: Cannot reach API at $API_URL"
          echo "## CRONOS: API Unreachable" >> "$GITHUB_STEP_SUMMARY"
          exit 1
        fi
        echo "API OK"

        FILES=""
        if git rev-parse HEAD~1 >/dev/null 2>&1; then
          FILES=$(git diff --name-only HEAD~1 HEAD | grep '\.py$' || true)
        else
          FILES=$(git ls-files '*.py' || true)
        fi

        if [ -z "$FILES" ]; then
          echo "No Python files changed"
          echo "## CRONOS: No changes detected" >> "$GITHUB_STEP_SUMMARY"
          exit 0
        fi

        echo "Analyzing: $FILES"
        FAIL_COUNT=0
        WARN_COUNT=0
        PASS_COUNT=0
        TOTAL=0

        for file in $FILES; do
          [ ! -f "$file" ] && continue
          TOTAL=$((TOTAL + 1))
          echo "--- $file ---"

          OLD_F=$(mktemp)
          NEW_F=$(mktemp)
          PAY_F=$(mktemp)
          RES_F=$(mktemp)
          SCR_F=$(mktemp).py

          if git rev-parse HEAD~1 >/dev/null 2>&1; then
            git show HEAD~1:"$file" > "$OLD_F" 2>/dev/null || true
          fi
          cp "$file" "$NEW_F"

          printf 'import json\n' > "$SCR_F"
          printf 'o=open("%s").read()\n' "$OLD_F" >> "$SCR_F"
          printf 'n=open("%s").read()\n' "$NEW_F" >> "$SCR_F"
          printf 'p={"old_code":o,"new_code":n,"mode":"%s"}\n' "$MODE" >> "$SCR_F"
          printf 'open("%s","w").write(json.dumps(p))\n' "$PAY_F" >> "$SCR_F"
          python3 "$SCR_F"
          rm -f "$OLD_F" "$NEW_F" "$SCR_F"

          set +e
          HTTP=$(curl -s -w "%{http_code}" -o "$RES_F" -X POST "$API_URL/analyze_ci" -H "Content-Type: application/json" -H "Accept: application/json" --max-time 60 -d "@$PAY_F")
          CE=$?
          set -e
          rm -f "$PAY_F"
          echo "HTTP=$HTTP exit=$CE"

          REPORT="$REPORT_DIR/$(echo $file | tr '/' '_').json"

          if [ "$CE" -ne 0 ]; then
            echo '{"status":"FAIL","risk":100,"findings_count":1,"summary":["curl error"]}' > "$REPORT"
            rm -f "$RES_F"; FAIL_COUNT=$((FAIL_COUNT+1)); continue
          fi
          if [ "$HTTP" != "200" ]; then
            echo '{"status":"FAIL","risk":100,"findings_count":1,"summary":["http error"]}' > "$REPORT"
            rm -f "$RES_F"; FAIL_COUNT=$((FAIL_COUNT+1)); continue
          fi

          SZ=$(wc -c < "$RES_F" || echo 0)
          if [ "$SZ" -eq 0 ]; then
            echo '{"status":"FAIL","risk":100,"findings_count":1,"summary":["empty response"]}' > "$REPORT"
            rm -f "$RES_F"; FAIL_COUNT=$((FAIL_COUNT+1)); continue
          fi

          if ! jq empty "$RES_F" 2>/dev/null; then
            echo '{"status":"FAIL","risk":100,"findings_count":1,"summary":["bad json"]}' > "$REPORT"
            rm -f "$RES_F"; FAIL_COUNT=$((FAIL_COUNT+1)); continue
          fi

          ST=$(jq -r '.status//"FAIL"' "$RES_F")
          RK=$(jq -r '.risk//100' "$RES_F")
          FN=$(jq -r '.findings_count//0' "$RES_F")

          cp "$RES_F" "$REPORT"

          echo "--------------------------------------------------"
          echo "File: $file"
          echo "Status: $ST"
          echo "Risk: $RK"
          echo "Findings: $FN"
          
          # Check and display optional fields in console
          if jq -e '.old_hash' "$RES_F" >/dev/null 2>&1; then
            OLD_H=$(jq -r '.old_hash' "$RES_F")
            echo "Old Hash: $OLD_H"
          fi
          if jq -e '.new_hash' "$RES_F" >/dev/null 2>&1; then
            NEW_H=$(jq -r '.new_hash' "$RES_F")
            echo "New Hash: $NEW_H"
          fi
          if jq -e '.ast_changed' "$RES_F" >/dev/null 2>&1; then
            AST_CH=$(jq -r '.ast_changed' "$RES_F")
            echo "AST Changed: $AST_CH"
          fi
          
          echo "---- Full Technical JSON ----"
          cat "$RES_F" || echo "{}"
          echo "--------------------------------------------------"

          # Build GitHub Step Summary
          printf -- '### %s\n' "$file" >> "$GITHUB_STEP_SUMMARY"
          printf -- '- Status: %s\n' "$ST" >> "$GITHUB_STEP_SUMMARY"
          printf -- '- Risk: %s/100\n' "$RK" >> "$GITHUB_STEP_SUMMARY"
          printf -- '- Findings: %s\n' "$FN" >> "$GITHUB_STEP_SUMMARY"
          
          # Add optional fields if they exist
          if jq -e '.old_hash' "$RES_F" >/dev/null 2>&1; then
            OLD_H=$(jq -r '.old_hash' "$RES_F")
            printf -- '- Old Hash: %s\n' "$OLD_H" >> "$GITHUB_STEP_SUMMARY"
          fi
          if jq -e '.new_hash' "$RES_F" >/dev/null 2>&1; then
            NEW_H=$(jq -r '.new_hash' "$RES_F")
            printf -- '- New Hash: %s\n' "$NEW_H" >> "$GITHUB_STEP_SUMMARY"
          fi
          if jq -e '.ast_changed' "$RES_F" >/dev/null 2>&1; then
            AST_CH=$(jq -r '.ast_changed' "$RES_F")
            printf -- '- AST Changed: %s\n' "$AST_CH" >> "$GITHUB_STEP_SUMMARY"
          fi
          
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "#### Human Summary" >> "$GITHUB_STEP_SUMMARY"
          jq -r '.summary[]//empty' "$RES_F" 2>/dev/null | sed 's/^/- /' >> "$GITHUB_STEP_SUMMARY" || true
          echo "" >> "$GITHUB_STEP_SUMMARY"

          rm -f "$RES_F"

          case "$ST" in
            PASS) PASS_COUNT=$((PASS_COUNT+1));;
            WARN) WARN_COUNT=$((WARN_COUNT+1));;
            *) FAIL_COUNT=$((FAIL_COUNT+1));;
          esac
        done

        echo "Done: total=$TOTAL pass=$PASS_COUNT warn=$WARN_COUNT fail=$FAIL_COUNT"
        printf '## CRONOS Summary\n- Passed: %s Warned: %s Failed: %s\n' "$PASS_COUNT" "$WARN_COUNT" "$FAIL_COUNT" >> "$GITHUB_STEP_SUMMARY"

        if [ "$FAIL_COUNT" -gt 0 ]; then exit 1; fi
        exit 0
