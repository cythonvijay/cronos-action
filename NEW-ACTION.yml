name: 'CRONOS Code Guard'
description: 'Static analysis for Python code changes with risk assessment'
author: 'cythonvijay'
branding:
  icon: 'shield'
  color: 'blue'

inputs:
  api_url:
    description: 'CRONOS API endpoint URL'
    required: true
  mode:
    description: 'Analysis mode: STRICT, BOUNDARY, or CONTRACT'
    required: false
    default: 'STRICT'

runs:
  using: 'composite'
  steps:
    - name: Install dependencies
      shell: bash
      run: |
        if ! command -v jq &> /dev/null; then
          sudo apt-get update -qq
          sudo apt-get install -y jq curl
        fi

    - name: Run CRONOS Analysis
      shell: bash
      env:
        API_URL: ${{ inputs.api_url }}
        MODE: ${{ inputs.mode }}
      run: |
        set -euo pipefail

        API_URL="${API_URL%/}"
        REPORT_DIR="cronos-reports"
        mkdir -p "$REPORT_DIR"

        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "ðŸš€ CRONOS Code Analysis"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "API: $API_URL"
        echo "Mode: $MODE"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""

        # Test API connectivity
        echo "Testing API..."
        if ! curl -sf --max-time 10 "$API_URL/" > /dev/null 2>&1; then
          echo "âŒ Cannot reach API at $API_URL"
          echo "## âŒ CRONOS: API Unreachable" >> "$GITHUB_STEP_SUMMARY"
          exit 1
        fi
        echo "âœ… API reachable"
        echo ""

        # Detect changed Python files
        FILES=""
        if git rev-parse HEAD~1 >/dev/null 2>&1; then
          FILES=$(git diff --name-only HEAD~1 HEAD | grep '\.py$' || true)
        else
          FILES=$(git ls-files '*.py' || true)
        fi

        if [ -z "$FILES" ]; then
          echo "âœ… No Python files changed"
          echo "## âœ… CRONOS: No changes detected" >> "$GITHUB_STEP_SUMMARY"
          exit 0
        fi

        echo "Files to analyze:"
        echo "$FILES"
        echo ""

        FAIL_COUNT=0
        WARN_COUNT=0
        PASS_COUNT=0
        TOTAL=0

        for file in $FILES; do
          [ ! -f "$file" ] && continue

          TOTAL=$((TOTAL + 1))
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ðŸ“„ File $TOTAL: $file"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          # Write old code to temp file
          OLD_FILE=$(mktemp /tmp/cronos_old_XXXXXX.py)
          NEW_FILE=$(mktemp /tmp/cronos_new_XXXXXX.py)
          PAYLOAD_FILE=$(mktemp /tmp/cronos_payload_XXXXXX.json)
          RESP_FILE=$(mktemp /tmp/cronos_resp_XXXXXX.json)

          # Get old code (empty string if first commit)
          if git rev-parse HEAD~1 >/dev/null 2>&1; then
            git show HEAD~1:"$file" > "$OLD_FILE" 2>/dev/null || echo -n "" > "$OLD_FILE"
          else
            echo -n "" > "$OLD_FILE"
          fi

          # Get new code
          cat "$file" > "$NEW_FILE"

          # Build JSON payload using Python (handles all special characters safely)
          python3 -c "
import json
with open('$OLD_FILE', 'r') as f:
    old = f.read()
with open('$NEW_FILE', 'r') as f:
    new = f.read()
payload = {'old_code': old, 'new_code': new, 'mode': '$MODE'}
with open('$PAYLOAD_FILE', 'w') as f:
    json.dump(payload, f)
print('Payload built: ' + str(len(json.dumps(payload))) + ' bytes')
"

          # Clean up temp code files
          rm -f "$OLD_FILE" "$NEW_FILE"

          echo "Sending to API..."

          # Call API using payload file (avoids any shell quoting issues)
          set +e
          HTTP_CODE=$(curl -s -w "%{http_code}" \
            -o "$RESP_FILE" \
            -X POST "$API_URL/analyze_ci" \
            -H "Content-Type: application/json" \
            -H "Accept: application/json" \
            --max-time 60 \
            -d "@$PAYLOAD_FILE")
          CURL_EXIT=$?
          set -e

          # Clean up payload file
          rm -f "$PAYLOAD_FILE"

          echo "HTTP: $HTTP_CODE (curl exit: $CURL_EXIT)"

          # Check curl succeeded
          if [ "$CURL_EXIT" -ne 0 ]; then
            echo "âŒ Network error (curl exit: $CURL_EXIT)"
            FAIL_COUNT=$((FAIL_COUNT + 1))
            echo '{"status":"FAIL","risk":100,"findings_count":1,"summary":["Network error"]}' > "$REPORT_DIR/${file//\//_}.json"
            rm -f "$RESP_FILE"
            continue
          fi

          # Check HTTP status
          if [ "$HTTP_CODE" != "200" ]; then
            echo "âŒ HTTP error: $HTTP_CODE"
            cat "$RESP_FILE" 2>/dev/null | head -5 || true
            FAIL_COUNT=$((FAIL_COUNT + 1))
            echo "{\"status\":\"FAIL\",\"risk\":100,\"findings_count\":1,\"summary\":[\"HTTP $HTTP_CODE error\"]}" > "$REPORT_DIR/${file//\//_}.json"
            rm -f "$RESP_FILE"
            continue
          fi

          # Check response has content
          RESP_SIZE=$(wc -c < "$RESP_FILE" 2>/dev/null || echo 0)
          echo "Response size: $RESP_SIZE bytes"

          if [ "$RESP_SIZE" -eq 0 ]; then
            echo "âŒ Empty response from API"
            FAIL_COUNT=$((FAIL_COUNT + 1))
            echo '{"status":"FAIL","risk":100,"findings_count":1,"summary":["Empty API response"]}' > "$REPORT_DIR/${file//\//_}.json"
            rm -f "$RESP_FILE"
            continue
          fi

          # Validate JSON
          if ! jq empty "$RESP_FILE" 2>/dev/null; then
            echo "âŒ Invalid JSON response:"
            cat "$RESP_FILE" | head -5
            FAIL_COUNT=$((FAIL_COUNT + 1))
            echo '{"status":"FAIL","risk":100,"findings_count":1,"summary":["Invalid JSON response"]}' > "$REPORT_DIR/${file//\//_}.json"
            rm -f "$RESP_FILE"
            continue
          fi

          # Parse results
          STATUS=$(jq -r '.status // "FAIL"' "$RESP_FILE")
          RISK=$(jq -r '.risk // 100' "$RESP_FILE")
          FINDINGS=$(jq -r '.findings_count // 0' "$RESP_FILE")

          # Save report
          cp "$RESP_FILE" "$REPORT_DIR/${file//\//_}.json"
          rm -f "$RESP_FILE"

          # Display results
          echo "Status: $STATUS"
          echo "Risk: $RISK/100"
          echo "Findings: $FINDINGS"

          if [ "$FINDINGS" -gt 0 ] 2>/dev/null; then
            echo "Summary:"
            jq -r '.summary[]?' "$REPORT_DIR/${file//\//_}.json" 2>/dev/null | head -3 | sed 's/^/  â€¢ /' || true
          fi

          # Add to GitHub summary
          {
            echo "### ðŸ“„ $file"
            echo ""
            echo "- **Status:** $STATUS"
            echo "- **Risk:** $RISK/100"
            echo "- **Findings:** $FINDINGS"
            echo ""
            if [ "$FINDINGS" -gt 0 ] 2>/dev/null; then
              jq -r '.summary[]?' "$REPORT_DIR/${file//\//_}.json" 2>/dev/null | head -3 | sed 's/^/- /' || true
              echo ""
            fi
          } >> "$GITHUB_STEP_SUMMARY"

          # Update counters
          case "$STATUS" in
            PASS) PASS_COUNT=$((PASS_COUNT + 1)); echo "âœ… PASS" ;;
            WARN) WARN_COUNT=$((WARN_COUNT + 1)); echo "âš ï¸  WARN" ;;
            FAIL) FAIL_COUNT=$((FAIL_COUNT + 1)); echo "âŒ FAIL" ;;
            *)    FAIL_COUNT=$((FAIL_COUNT + 1)); echo "âŒ UNKNOWN: $STATUS" ;;
          esac
          echo ""
        done

        # Final summary
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "ðŸ“Š Analysis Complete"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "Total:    $TOTAL"
        echo "âœ… Passed:  $PASS_COUNT"
        echo "âš ï¸  Warned:  $WARN_COUNT"
        echo "âŒ Failed:  $FAIL_COUNT"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

        {
          echo "## ðŸ“Š CRONOS Analysis Summary"
          echo ""
          echo "- **Total files:** $TOTAL"
          echo "- **âœ… Passed:** $PASS_COUNT"
          echo "- **âš ï¸ Warnings:** $WARN_COUNT"
          echo "- **âŒ Failed:** $FAIL_COUNT"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"

        if [ "$FAIL_COUNT" -gt 0 ]; then
          echo "ðŸš« BUILD BLOCKED - $FAIL_COUNT file(s) failed"
          exit 1
        else
          echo "âœ… BUILD APPROVED"
          exit 0
        fi
